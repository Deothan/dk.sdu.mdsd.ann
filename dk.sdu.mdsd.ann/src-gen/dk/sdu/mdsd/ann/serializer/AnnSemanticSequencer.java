/*
 * generated by Xtext 2.11.0
 */
package dk.sdu.mdsd.ann.serializer;

import com.google.inject.Inject;
import dk.sdu.mdsd.ann.ann.ANNModel;
import dk.sdu.mdsd.ann.ann.AnnPackage;
import dk.sdu.mdsd.ann.ann.Custom;
import dk.sdu.mdsd.ann.ann.Hidden;
import dk.sdu.mdsd.ann.ann.Input;
import dk.sdu.mdsd.ann.ann.Output;
import dk.sdu.mdsd.ann.ann.Sigmoid;
import dk.sdu.mdsd.ann.ann.Threshold;
import dk.sdu.mdsd.ann.services.AnnGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AnnSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AnnGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AnnPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AnnPackage.ANN_MODEL:
				sequence_ANNModel(context, (ANNModel) semanticObject); 
				return; 
			case AnnPackage.CUSTOM:
				sequence_Custom(context, (Custom) semanticObject); 
				return; 
			case AnnPackage.HIDDEN:
				sequence_Hidden(context, (Hidden) semanticObject); 
				return; 
			case AnnPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case AnnPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case AnnPackage.SIGMOID:
				sequence_Sigmoid(context, (Sigmoid) semanticObject); 
				return; 
			case AnnPackage.THRESHOLD:
				sequence_Threshold(context, (Threshold) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ANNModel returns ANNModel
	 *
	 * Constraint:
	 *     (name=ID alpha=DECIMAL epochs=INT Layer+=Layer+)
	 */
	protected void sequence_ANNModel(ISerializationContext context, ANNModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LearningRule returns Custom
	 *     Custom returns Custom
	 *
	 * Constraint:
	 *     (name=ID function=ID)
	 */
	protected void sequence_Custom(ISerializationContext context, Custom semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.CUSTOM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.CUSTOM__NAME));
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.CUSTOM__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.CUSTOM__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCustomAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCustomAccess().getFunctionIDTerminalRuleCall_2_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Layer returns Hidden
	 *     Hidden returns Hidden
	 *
	 * Constraint:
	 *     (size=INT l_rule=LearningRule)
	 */
	protected void sequence_Hidden(ISerializationContext context, Hidden semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.LAYER__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.LAYER__SIZE));
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.HIDDEN__LRULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.HIDDEN__LRULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHiddenAccess().getSizeINTTerminalRuleCall_3_0(), semanticObject.getSize());
		feeder.accept(grammarAccess.getHiddenAccess().getL_ruleLearningRuleParserRuleCall_5_0(), semanticObject.getL_rule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Layer returns Input
	 *     Input returns Input
	 *
	 * Constraint:
	 *     size=INT
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.LAYER__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.LAYER__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputAccess().getSizeINTTerminalRuleCall_3_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Layer returns Output
	 *     Output returns Output
	 *
	 * Constraint:
	 *     (size=INT l_rule=LearningRule)
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.LAYER__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.LAYER__SIZE));
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.OUTPUT__LRULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.OUTPUT__LRULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputAccess().getSizeINTTerminalRuleCall_3_0(), semanticObject.getSize());
		feeder.accept(grammarAccess.getOutputAccess().getL_ruleLearningRuleParserRuleCall_5_0(), semanticObject.getL_rule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LearningRule returns Sigmoid
	 *     Sigmoid returns Sigmoid
	 *
	 * Constraint:
	 *     rule='sigmoid'
	 */
	protected void sequence_Sigmoid(ISerializationContext context, Sigmoid semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.SIGMOID__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.SIGMOID__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSigmoidAccess().getRuleSigmoidKeyword_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LearningRule returns Threshold
	 *     Threshold returns Threshold
	 *
	 * Constraint:
	 *     rule='threshold'
	 */
	protected void sequence_Threshold(ISerializationContext context, Threshold semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.THRESHOLD__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.THRESHOLD__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThresholdAccess().getRuleThresholdKeyword_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
}
