/*
 * generated by Xtext 2.11.0
 */
package dk.sdu.mdsd.ann.serializer;

import com.google.inject.Inject;
import dk.sdu.mdsd.ann.ann.ANNModel;
import dk.sdu.mdsd.ann.ann.Add;
import dk.sdu.mdsd.ann.ann.AnnPackage;
import dk.sdu.mdsd.ann.ann.Custom;
import dk.sdu.mdsd.ann.ann.Div;
import dk.sdu.mdsd.ann.ann.External;
import dk.sdu.mdsd.ann.ann.Hidden;
import dk.sdu.mdsd.ann.ann.Input;
import dk.sdu.mdsd.ann.ann.Letter;
import dk.sdu.mdsd.ann.ann.Multi;
import dk.sdu.mdsd.ann.ann.NumberLiteral;
import dk.sdu.mdsd.ann.ann.Output;
import dk.sdu.mdsd.ann.ann.Sigmoid;
import dk.sdu.mdsd.ann.ann.Sub;
import dk.sdu.mdsd.ann.services.AnnGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AnnSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AnnGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AnnPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AnnPackage.ANN_MODEL:
				sequence_ANNModel(context, (ANNModel) semanticObject); 
				return; 
			case AnnPackage.ADD:
				sequence_Expression(context, (Add) semanticObject); 
				return; 
			case AnnPackage.CUSTOM:
				sequence_Custom(context, (Custom) semanticObject); 
				return; 
			case AnnPackage.DIV:
				sequence_Division(context, (Div) semanticObject); 
				return; 
			case AnnPackage.EXTERNAL:
				sequence_External(context, (External) semanticObject); 
				return; 
			case AnnPackage.HIDDEN:
				sequence_Hidden(context, (Hidden) semanticObject); 
				return; 
			case AnnPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case AnnPackage.LETTER:
				sequence_Letter(context, (Letter) semanticObject); 
				return; 
			case AnnPackage.MULTI:
				sequence_Multiplication(context, (Multi) semanticObject); 
				return; 
			case AnnPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case AnnPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case AnnPackage.SIGMOID:
				sequence_Sigmoid(context, (Sigmoid) semanticObject); 
				return; 
			case AnnPackage.SUB:
				sequence_Substraction(context, (Sub) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ANNModel returns ANNModel
	 *
	 * Constraint:
	 *     (name=ID alpha=DECIMAL epochs=INT Layer+=Layer+)
	 */
	protected void sequence_ANNModel(ISerializationContext context, ANNModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LearningRule returns Custom
	 *     Custom returns Custom
	 *
	 * Constraint:
	 *     (name=ID exp=Expression der=Expression)
	 */
	protected void sequence_Custom(ISerializationContext context, Custom semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.CUSTOM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.CUSTOM__NAME));
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.CUSTOM__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.CUSTOM__EXP));
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.CUSTOM__DER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.CUSTOM__DER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCustomAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCustomAccess().getExpExpressionParserRuleCall_5_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getCustomAccess().getDerExpressionParserRuleCall_8_0(), semanticObject.getDer());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Div
	 *     Expression.Add_1_0 returns Div
	 *     Substraction returns Div
	 *     Substraction.Sub_1_0 returns Div
	 *     Multiplication returns Div
	 *     Multiplication.Multi_1_0 returns Div
	 *     Division returns Div
	 *     Division.Div_1_0 returns Div
	 *     Primary returns Div
	 *
	 * Constraint:
	 *     (left=Division_Div_1_0 right=Primary)
	 */
	protected void sequence_Division(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivisionAccess().getDivLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDivisionAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Add
	 *     Expression.Add_1_0 returns Add
	 *     Substraction returns Add
	 *     Substraction.Sub_1_0 returns Add
	 *     Multiplication returns Add
	 *     Multiplication.Multi_1_0 returns Add
	 *     Division returns Add
	 *     Division.Div_1_0 returns Add
	 *     Primary returns Add
	 *
	 * Constraint:
	 *     (left=Expression_Add_1_0 right=Substraction)
	 */
	protected void sequence_Expression(ISerializationContext context, Add semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.ADD__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.ADD__LEFT));
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.ADD__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.ADD__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getAddLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightSubstractionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LearningRule returns External
	 *     External returns External
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_External(ISerializationContext context, External semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.EXTERNAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.EXTERNAL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Layer returns Hidden
	 *     Hidden returns Hidden
	 *
	 * Constraint:
	 *     (size=INT l_rule=LearningRule)
	 */
	protected void sequence_Hidden(ISerializationContext context, Hidden semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.LAYER__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.LAYER__SIZE));
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.HIDDEN__LRULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.HIDDEN__LRULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHiddenAccess().getSizeINTTerminalRuleCall_3_0(), semanticObject.getSize());
		feeder.accept(grammarAccess.getHiddenAccess().getL_ruleLearningRuleParserRuleCall_5_0(), semanticObject.getL_rule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Layer returns Input
	 *     Input returns Input
	 *
	 * Constraint:
	 *     size=INT
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.LAYER__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.LAYER__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputAccess().getSizeINTTerminalRuleCall_3_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Letter
	 *     Expression.Add_1_0 returns Letter
	 *     Substraction returns Letter
	 *     Substraction.Sub_1_0 returns Letter
	 *     Multiplication returns Letter
	 *     Multiplication.Multi_1_0 returns Letter
	 *     Division returns Letter
	 *     Division.Div_1_0 returns Letter
	 *     Primary returns Letter
	 *     Letter returns Letter
	 *
	 * Constraint:
	 *     value='x'
	 */
	protected void sequence_Letter(ISerializationContext context, Letter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.LETTER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.LETTER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetterAccess().getValueXKeyword_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Multi
	 *     Expression.Add_1_0 returns Multi
	 *     Substraction returns Multi
	 *     Substraction.Sub_1_0 returns Multi
	 *     Multiplication returns Multi
	 *     Multiplication.Multi_1_0 returns Multi
	 *     Division returns Multi
	 *     Division.Div_1_0 returns Multi
	 *     Primary returns Multi
	 *
	 * Constraint:
	 *     (left=Multiplication_Multi_1_0 right=Division)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multi semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.MULTI__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.MULTI__LEFT));
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.MULTI__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.MULTI__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getMultiLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightDivisionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberLiteral
	 *     Expression.Add_1_0 returns NumberLiteral
	 *     Substraction returns NumberLiteral
	 *     Substraction.Sub_1_0 returns NumberLiteral
	 *     Multiplication returns NumberLiteral
	 *     Multiplication.Multi_1_0 returns NumberLiteral
	 *     Division returns NumberLiteral
	 *     Division.Div_1_0 returns NumberLiteral
	 *     Primary returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     value=DECIMAL
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValueDECIMALParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Layer returns Output
	 *     Output returns Output
	 *
	 * Constraint:
	 *     (size=INT l_rule=LearningRule)
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.LAYER__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.LAYER__SIZE));
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.OUTPUT__LRULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.OUTPUT__LRULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputAccess().getSizeINTTerminalRuleCall_3_0(), semanticObject.getSize());
		feeder.accept(grammarAccess.getOutputAccess().getL_ruleLearningRuleParserRuleCall_5_0(), semanticObject.getL_rule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LearningRule returns Sigmoid
	 *     Sigmoid returns Sigmoid
	 *
	 * Constraint:
	 *     rule='sigmoid'
	 */
	protected void sequence_Sigmoid(ISerializationContext context, Sigmoid semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.SIGMOID__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.SIGMOID__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSigmoidAccess().getRuleSigmoidKeyword_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Sub
	 *     Expression.Add_1_0 returns Sub
	 *     Substraction returns Sub
	 *     Substraction.Sub_1_0 returns Sub
	 *     Multiplication returns Sub
	 *     Multiplication.Multi_1_0 returns Sub
	 *     Division returns Sub
	 *     Division.Div_1_0 returns Sub
	 *     Primary returns Sub
	 *
	 * Constraint:
	 *     (left=Substraction_Sub_1_0 right=Multiplication)
	 */
	protected void sequence_Substraction(ISerializationContext context, Sub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.SUB__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.SUB__LEFT));
			if (transientValues.isValueTransient(semanticObject, AnnPackage.Literals.SUB__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnPackage.Literals.SUB__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubstractionAccess().getSubLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSubstractionAccess().getRightMultiplicationParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
