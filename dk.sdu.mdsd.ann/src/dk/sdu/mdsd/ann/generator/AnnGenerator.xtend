/*
 * generated by Xtext 2.11.0
 */
package dk.sdu.mdsd.ann.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mdsd.ann.ann.ANNModel
import dk.sdu.mdsd.ann.ann.Hidden
import dk.sdu.mdsd.ann.ann.Input
import dk.sdu.mdsd.ann.ann.Output
import dk.sdu.mdsd.ann.ann.Custom
import dk.sdu.mdsd.ann.ann.Multi
import dk.sdu.mdsd.ann.ann.Add
import dk.sdu.mdsd.ann.ann.NumberLiteral
import dk.sdu.mdsd.ann.ann.Sub
import dk.sdu.mdsd.ann.ann.Div
import dk.sdu.mdsd.ann.ann.Letter
import dk.sdu.mdsd.ann.ann.External
import dk.sdu.mdsd.ann.ann.Sigmoid
import dk.sdu.mdsd.ann.ann.Tansig

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class AnnGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		resource.allContents.filter(typeof(ANNModel)).forEach[generateANNFile(fsa, resource)]
		resource.allContents.filter(typeof(Custom)).forEach[generateCustomFunctionFile(fsa, resource)]
		resource.allContents.filter(typeof(Sigmoid)).forEach[generateSigmoid(fsa)]
		resource.allContents.filter(typeof(Tansig)).forEach[generateTansig(fsa)]
	}
	
	
	def generateANNFile(ANNModel m, IFileSystemAccess2 access2, Resource resource) {
		access2.generateFile(m.name+".java", m.generateNetwork)
		access2.generateFile("ITransfer.java", generateITransfer())
		access2.generateFile("Helpers.java",generateHelpers())
		access2.generateFile("ANN.java",generateJavaANN())
		access2.generateFile("ITransferFactory.java",m.generateITransferFactory(resource))
	}
	
	def generateCustomFunctionFile(Custom c, IFileSystemAccess2 access2, Resource resource) {
		access2.generateFile(c.name + ".java", c.generateCustomFunction)
	}

	def generateITransfer() '''
	public interface ITransfer {
		double transfer(double x);
		double derivative(double x);
	}
	'''
	
	def generateSigmoid(Sigmoid sig,IFileSystemAccess2 fsa ){
		fsa.generateFile("Sigmoid.java", generateSigmoid())
	}
		
	
	def generateTansig(Tansig tan,IFileSystemAccess2 fsa) {
		fsa.generateFile("Tansig.java", generateTansig())
	}
		
	def generateSigmoid() '''
	public class Sigmoid implements ITransfer {
		public double transfer(double x){
				return (1 / (1 + Math.exp(x)));		
			}
		public double derivative(double x){
				return x*(1-x);
			}
	}
	'''
	
	def generateTansig() '''
	public class Tansig implements ITransfer {
		public double transfer(double x){
				return 2/(1+Math.exp(-2*n))-1;
			}
		public double derivative(double x){
				return 1-Math.pow(a,2);
			}
	}
	'''
	
	def generateHelpers()'''
	public class Helpers {
	    public static double dot(double[] a, double[] b) {
	        int n = a.length;
	        double sum = 0;
	        for (int i = 0; i < n; i++) {
	            sum += a[i] * b[i];
	        }
	        return sum;
	    }
	    public static double[][] transpose(double[][] array) {
	        if (array == null || array.length == 0)//empty or unset array, nothing do to here
	            return array;
	        int width = array.length - 1;
	        int height = array[0].length;
	        double[][] array_new = new double[height][width];
	        for (int x = 0; x < width; x++) {
	            for (int y = 0; y < height; y++) {
	                array_new[y][x] = array[x][y];
	            }
	        }
	        return array_new;
	    }
	}
	'''
	
	def generateJavaANN() '''
	import java.util.ArrayList;

	public class ANN {
	    int[] l_size;
	    double[][] layers;
	    ArrayList<double[][]> weights;
	    double[][] errors;
	    double[][] deltas;
	    ArrayList<ITransfer> transfers;
	    ArrayList<double[]> input;
	    int[] y;
	    double alpha;
	    int epochs;
	    public ANN(int[] sizes, ArrayList<ITransfer> transfers, double alpha, int epochs, ArrayList<double[]> input, int[] y) {
	        this.weights = new ArrayList<>();
	        this.layers = new double[sizes.length - 1][];
	        this.deltas = new double[sizes.length][];
	        this.transfers = new ArrayList<>(transfers);
	        this.errors = new double[sizes.length][];
	        this.l_size = sizes;
	        this.y = y;
	        this.input = input;
	        this.alpha = alpha;
	        this.epochs = epochs;
	    }
	    //Random initialization of weights
	    public void setupWeights() {
	        for (int i = 0; i < layers.length; i++) {
	            double[][] tmp = new double[l_size[i]][l_size[i + 1]];
	            for (int j = 0; j < tmp.length; j++) {
	                for (int k = 0; k < tmp[0].length; k++) {
	                    tmp[j][k] = 2 * Math.random() - 1;
	                }
	            }
	            weights.add(tmp);
	        }
	    }
	    //taking the input through the layers
	    public void runThroughLayers(double[] in) {
	        double[] tmp = in;
	        //Run through all layers, using weights
	        for (int i = 0; i < l_size.length - 1; i++) {
	            //Temporary array with layer results
	            double[] t = new double[l_size[i + 1]];
	            for (int k = 0; k < weights.get(i)[0].length; k++) {
	                double sum = 0;
	                for (int j = 0; j < tmp.length - 1; j++) {
	                    sum += weights.get(i)[j][k] * tmp[j];
	                }
	                t[k] = transfers.get(i).transfer(sum);
	            }
	            layers[i] = t;
	            tmp = layers[i];
	        }
	    }
	    public void calcErrorAndDelta(int y) {
	        //This is for the output layer
	        double[] tmpError;
	        double[] tmpDelta;
	        tmpError = new double[]{layers[layers.length - 1][0] - y};
	        errors[errors.length - 1] = tmpError;
	        tmpDelta = new double[]{errors[errors.length - 1][0] * transfers.get(transfers.size() - 1).derivative(layers[layers.length - 1][0])};
	        deltas[deltas.length - 1] = tmpDelta;
	        //Now for the rest of the layers.
	        for (int i = layers.length - 1; i >= 0; i--) {
	            tmpDelta = new double[layers[i].length];
	            tmpError = new double[layers[i].length];
	            double[][] tmpLayer = Helpers.transpose(weights.get(i));
	            int count = 0;
	            for (double[] t : tmpLayer) {
	                double sum = 0;
	                for (double d : t) {
	                    for (double s : deltas[i + 1]) {
	                        sum += d * s;
	                    }
	                }
	                tmpError[count] = sum;
	                count++;
	            }
	            count = 0;
	            for (double d : tmpError) {
	                double sum = 0;
	                for (double s : layers[i]) {
	                    sum += d * (transfers.get(i).derivative(s));
	                }
	                tmpDelta[count] = sum;
	                count++;
	            }
	            errors[i] = tmpError;
	            deltas[i] = tmpDelta;
	        }
	    }
	    public void updateWeights() {
	        for (int i = layers.length - 1; i >= 1; i--) {
	            double[][] full = new double[l_size[i]][];
	            double sum = 0;
	            for (int l = 0; l < layers[i - 1].length; l++) {
	                double[] temp = new double[l_size[i + 1]];
	                for (int t = 0; t < deltas[i + 1].length; t++) {
	                    sum = weights.get(i)[l][t] + (alpha * (layers[i - 1][l] * deltas[i + 1][t]));
	                    temp[t] = sum;
	                }
	                full[l] = temp;
	            }
	            weights.set(i, full);
	        }
	        double[][] full = new double[l_size[0]][];
	        double sum = 0;
	        for (int l = 0; l < l_size[0] - 1; l++) {
	            double[] temp = new double[l_size[1]];
	            for (int t = 0; t < deltas[0].length; t++) {
	                sum = weights.get(0)[l][t] + (alpha * (layers[0][l] * deltas[0][t]));
	                temp[t] = sum;
	            }
	            full[l] = temp;
	        }
	        weights.set(0, full);
	    }
	    public void run() {
	        setupWeights();
	        for (int j = 0; j < epochs; j++) {
	            for (int i = 0; i < input.size(); i++) {
	                runThroughLayers(input.get(i));
	                calcErrorAndDelta(y[i]);
	                updateWeights();
	                System.out.println("Prediction = " + Math.round(layers[layers.length - 1][0]) + " Actual = " + y[i]);
	            }
	        }
	    }
	}
	'''
	
	def CharSequence generateITransferFactory(ANNModel model, Resource resource) '''
	public interface ITransferFactory {
		«FOR l: model.layer»
		«if(l instanceof Hidden){
			if(l.l_rule instanceof External) {
				(l.l_rule as External).generateGetLineForITransferFactory
			}
		}»
		«ENDFOR»
	}
	'''
	
	def CharSequence generateGetLineForITransferFactory(External ext) '''
		ITransfer get«ext.name.toFirstUpper»();
	'''
	
	def CharSequence generateNetwork(ANNModel model) '''
	import java.util.*;

	public class «model.name» {
		private double alpha = «model.alpha»;
		private int epochs = «model.epochs»;
		private List<Double> layers;
		private List<ITransfer> transfers;
		
		public «model.name»(ITransferFactory factory) {
			layers = new ArrayList<>();
			transfers = new ArrayList<>();
			init(factory);
		}
		
		public Double[] getLayers() {
			return (Double[])this.layers.toArray();
		}
		
		public String[] getTransfers() {
			return (String[])this.transfers.toArray();
		}
	
		public void addLayerWithTransfer(double size, ITransfer transfer) {
			if(transfer == null) {
				this.layers.add(size);
			} else {
				this.layers.add(size);
				this.transfers.add(transfer);
			}
		}
		
		public double getAlpha() {
			return this.alpha;
		}
		
		public void setAlpha(double alpha) {
			this.alpha = alpha;
		}
		
		public int getEpochs() {
			return this.epochs;
		}
		
		public void setEpochs(int epochs) {
			this.epochs = epochs;
		}
		
		private void init(ITransferFactory factory) {
			«FOR l: model.layer»
			«l.generateLayer»
			«ENDFOR»
		}
	}
	'''
	
	def CharSequence generateCustomFunction(Custom customFunction) '''
	public class «customFunction.name» implements ITransfer {
		
		public double transfer(double x) {
			return «customFunction.generateCustomExp»
		}
		public double derivative(double x) {
			return «customFunction.generateCustomDer»
		}
	}
	'''
	
	def generateCustomExp(Custom custom) '''
		«custom.exp.generateExp»;
	'''
	
	def generateCustomDer(Custom custom) '''
		«custom.der.generateExp»;
	'''
		
	def dispatch CharSequence generateExp(Add exp) '''(«exp.left.generateExp»+«exp.right.generateExp»)'''
	
	def dispatch CharSequence generateExp(Sub exp) '''(«exp.left.generateExp»-«exp.right.generateExp»)'''
	
	def dispatch CharSequence generateExp(Multi exp) '''(«exp.left.generateExp»*«exp.right.generateExp»)'''
	
	def dispatch CharSequence generateExp(Div exp) '''(«exp.left.generateExp»/«exp.right.generateExp»)'''
	
	def dispatch CharSequence generateExp(NumberLiteral exp) '''«exp.value»'''
	
	def dispatch CharSequence generateExp(Letter exp) '''«exp.value»'''
	
	def dispatch generateLayer(Hidden layer) '''
		addLayerWithTransfer(«layer.size», «layer.l_rule.generateRule»);
	'''
	
	def dispatch generateLayer(Input layer) '''
		addLayerWithTransfer(«layer.size», null);
	'''
		
	def dispatch generateLayer(Output layer) '''
		addLayerWithTransfer(«layer.size», «layer.l_rule.generateRule»);

	'''
	
	def dispatch generateRule(Sigmoid rule)'''new «rule.rule»()'''
		
	def dispatch generateRule(Tansig rule)'''new «rule.rule»()'''
	
	def dispatch generateRule(External rule)'''factory.get«rule.name.toFirstUpper»()''' 
		
	
	def dispatch generateRule(Custom rule)'''new «rule.name»()'''
	
	
}